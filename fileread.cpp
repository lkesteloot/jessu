
/*
 * FileRead.cpp
 *
 * $Id: fileread.cpp,v 1.20 2004/03/28 00:39:44 lk Exp $
 *
 * $Log: fileread.cpp,v $
 * Revision 1.20  2004/03/28 00:39:44  lk
 * Fix tile edge clamp problem.
 *
 * Revision 1.19  2004/03/20 02:22:30  lk
 * Code cleanup; allow debug file even in release (to help people with
 * problems).
 *
 * Revision 1.18  2004/03/12 20:03:10  lk
 * Use exceptions rather than longjmp.
 *
 * Revision 1.17  2004/03/07 01:27:32  lk
 * Don't display images that are smaller than 200x200.  (I'm checking
 * this in from Happy Donuts in Palo Alto!)
 *
 * Revision 1.16  2003/08/18 02:21:09  lk
 * Remove dead code and add comment about our choice of JPEG library.
 *
 * Revision 1.15  2003/07/22 04:50:37  lk
 * Use less memory.
 *
 * Revision 1.14  2003/01/30 06:29:55  lk
 * Deal better with read errors
 *
 * Revision 1.13  2003/01/28 05:54:39  lk
 * Even better debugging.
 *
 * Revision 1.12  2003/01/28 03:27:54  lk
 * Nicer scaling horizontally.
 *
 * Revision 1.11  2003/01/28 02:46:21  lk
 * Much better logging, horizontal resize on load
 *
 * Revision 1.10  2003/01/27 22:07:21  lk
 * Keep around contribution arrays
 *
 * Revision 1.9  2002/08/23 17:45:53  grantham
 * Debug changes
 *
 * Revision 1.8  2002/02/24 19:04:15  lk
 * Smarter about memory usage and seeding random generator.
 *
 * Revision 1.7  2002/02/21 22:56:20  lk
 * Whoops, wrong capitalization on RCS tags
 *
 * Revision 1.6  2002/02/21 22:55:15  lk
 * Added RCS tags and per-file comment
 *
 * We use the Independent JPEG Group library version 6b with JDCT_ISLOW.
 * See http://stereopsis.com/jpg/
 *
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>

#include "fileread.h"
#include "jessu.h"
#include "scaletile.h"

extern "C" {
#include "jpeglib.h"
}

// 200 pixels in both directions
#define MINIMUM_SIZE        200

struct JPEGReadException {
    char m_error_message[JMSG_LENGTH_MAX];

    JPEGReadException(j_common_ptr cinfo) {
        (*cinfo->err->format_message)(cinfo, m_error_message);
    }
};

static char *current_filename = NULL;

static void
dummy_exit(j_common_ptr cinfo)
{
    throw JPEGReadException(cinfo);
}

static unsigned char *
get_row_buffer(int size)
{
    static unsigned char *buffer = NULL;
    static int current_size;

    if (buffer == NULL) {
        buffer = (unsigned char *)jessu_malloc(THREAD_WORKER,
                size, "jpeg row buffer");
        current_size = size;
    } else {
        if (size > current_size) {
            buffer = (unsigned char *)jessu_realloc(THREAD_WORKER,
                    buffer, size, "jpeg row buffer");
            current_size = size;
        }
    }

    return buffer;
}

static int
read_jpeg(FILE *jpegFile, Vertical_scaler &vertical_scaler,
        int *width, int *height)
{
    struct jpeg_error_mgr jerr;
    struct jpeg_decompress_struct dcinfo;
    unsigned int i;
    unsigned char *row_buffer;
    CLIST *clist;
    bool decompress_created = false;
    int error;
    int success = false;

    /* create error handler */
    jpeg_std_error(&jerr);
    jerr.error_exit = dummy_exit;
    dcinfo.err = &jerr;

    // dummy_exit() will throw up an exception on error
    try {

        /* set dcinfo for compression */
        jpeg_create_decompress(&dcinfo);
        decompress_created = true;

        /* 3 and RGB space corresponds to GL_RGB */
        dcinfo.output_components = 3;
        dcinfo.out_color_space = JCS_RGB;

        /* use jpegFile for reading image */
        jpeg_stdio_src(&dcinfo, jpegFile);

        /* read JFIF header */
        error = jpeg_read_header(&dcinfo, FALSE);
        if (error != JPEG_HEADER_OK) {
            jessu_printf(THREAD_WORKER, "Bad JPEG header");
            goto error_exit;
        }

        jpeg_start_decompress(&dcinfo);

        // don't show the image if it's too small (usually a thumbnail
        // generated by some program) because it looks awful when blown up.
        if (dcinfo.image_width < MINIMUM_SIZE &&
                dcinfo.image_height < MINIMUM_SIZE) {

            goto error_exit;
        }

        *width = dcinfo.image_width;
        *height = dcinfo.image_height;
        vertical_scaler.Set_source_parameters(*width, *height);

        // temporary buffer just for this row
        row_buffer = get_row_buffer(*width*3);
        JSAMPROW rowPtr[1];
        rowPtr[0] = row_buffer;

        clist = get_scale_row_data(*width, vertical_scaler.m_texture_size_x,
                vertical_scaler.m_tile_size_x);

        /* read JPEG image rows */
        for (i = 0; i < dcinfo.image_height; i++) {
            loading_jpeg_progress = i*100/dcinfo.image_height;

            if (i % 200 == 0) {
                // give other threads a chance.  is this really necessary?
                jessu_printf(THREAD_WORKER, "reading line %d", i);
                Sleep(0);
            }

            if (jpeg_read_scanlines(&dcinfo, rowPtr, 1) != 1) {
                fprintf(debug_output, "Failed reading JPEG row %d.\n", i);
                return 0;
            }

            /* check for grayscale */
            if (dcinfo.num_components == 1) {
                /* convert to color */
                for (int j = dcinfo.image_width - 1; j >= 0; j--) {
                    JSAMPLE s = row_buffer[j];
                    row_buffer[j*3 + 0] = s;
                    row_buffer[j*3 + 1] = s;
                    row_buffer[j*3 + 2] = s;
                }
            }

            // we go bottom up because we use texcoord t=0 at bottom, t=1 at
            // top (could easily load top down and just reverse texcoord t's)
            unsigned char *target_row = vertical_scaler.Get_row_buffer(i);

            // scale horizontally to texture size
            scale_row(clist, row_buffer, target_row,
                    vertical_scaler.m_texture_size_x);

            // scale vertically to texture size 
            vertical_scaler.Process_row(i);
        }

        jpeg_finish_decompress(&dcinfo);

        success = true;

    } catch (const JPEGReadException &exception) {
        jessu_printf(THREAD_WORKER,
                "JPEG library could not read \"%s\" (%s)",
                current_filename, exception.m_error_message);

    }

error_exit:
    if (decompress_created) {
        jpeg_destroy_decompress(&dcinfo);
        decompress_created = false;
    }

    return success;
}

int
read_image(char *name, FILE *fp, Vertical_scaler &vertical_scaler,
        int *width, int *height)
{
    int len = strlen(name);

    if ((len >= 4 && stricmp(name + strlen(name) - 4, ".jpg") == 0) ||
        (len >= 5 && stricmp(name + strlen(name) - 5, ".jpeg") == 0)) {

        current_filename = name;
        jessu_printf(THREAD_WORKER, "reading file %s", name);
	return read_jpeg(fp, vertical_scaler, width, height);
    }

    fprintf(debug_output, "No code to read file \"%s\"\n", name);

    return FALSE;
}

